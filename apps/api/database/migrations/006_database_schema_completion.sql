-- Migration: Complete Database Schema Updates
-- Date: 2026-01-07
-- Version: 2.2.0
-- Description: Add missing fields for full API compatibility and create notifications/service_history tables

-- =============================================================================
-- Add missing fields to USERS table
-- =============================================================================

-- Add total_bookings counter
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'total_bookings'
    ) THEN
        ALTER TABLE users ADD COLUMN total_bookings INTEGER DEFAULT 0;
        COMMENT ON COLUMN users.total_bookings IS 'Cached count of total bookings for this user';
    END IF;
END $$;

-- Update last_login to last_login_at for consistency
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'last_login'
    ) AND NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'last_login_at'
    ) THEN
        ALTER TABLE users RENAME COLUMN last_login TO last_login_at;
    END IF;
END $$;

-- =============================================================================
-- Add missing fields to SERVICES table
-- =============================================================================

-- Add total_bookings counter
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'services' AND column_name = 'total_bookings'
    ) THEN
        ALTER TABLE services ADD COLUMN total_bookings INTEGER DEFAULT 0;
        COMMENT ON COLUMN services.total_bookings IS 'Cached count of total bookings for this service';
    END IF;
END $$;

-- Add total_revenue tracker
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'services' AND column_name = 'total_revenue'
    ) THEN
        ALTER TABLE services ADD COLUMN total_revenue DECIMAL(12, 2) DEFAULT 0;
        COMMENT ON COLUMN services.total_revenue IS 'Cached total revenue generated by this service';
    END IF;
END $$;

-- =============================================================================
-- Add missing fields to BOOKINGS table
-- =============================================================================

-- Add queue_position for tracking
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'bookings' AND column_name = 'queue_position'
    ) THEN
        ALTER TABLE bookings ADD COLUMN queue_position INTEGER;
        COMMENT ON COLUMN bookings.queue_position IS 'Position in queue for processing';
    END IF;
END $$;

-- Ensure staff_id column exists (either as assigned_staff_id or staff_id)
DO $$
BEGIN
    -- If column is named assigned_staff_id, optionally add alias or use as-is
    -- The schema.sql already has assigned_staff_id, so we're good
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'bookings' AND column_name = 'assigned_staff_id'
    ) AND NOT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'bookings' AND column_name = 'staff_id'
    ) THEN
        ALTER TABLE bookings ADD COLUMN assigned_staff_id UUID REFERENCES employees(id) ON DELETE SET NULL;
        COMMENT ON COLUMN bookings.assigned_staff_id IS 'Staff member assigned to this booking';
    END IF;
END $$;

-- =============================================================================
-- Create NOTIFICATIONS table
-- =============================================================================

CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,

    -- Notification content
    title VARCHAR(200) NOT NULL,
    message TEXT NOT NULL,
    type VARCHAR(50) NOT NULL DEFAULT 'info', -- 'info', 'success', 'warning', 'error', 'booking', 'payment'

    -- Status
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMP,

    -- Actions
    action_url TEXT,
    action_label VARCHAR(100),

    -- Related entities
    booking_id UUID REFERENCES bookings(id) ON DELETE CASCADE,
    related_entity_type VARCHAR(50), -- 'booking', 'payment', 'service', 'user'
    related_entity_id UUID,

    -- Delivery channels
    sent_via JSONB DEFAULT '{"app": true, "email": false, "sms": false}'::jsonb,

    -- Priority
    priority VARCHAR(20) DEFAULT 'normal', -- 'low', 'normal', 'high', 'urgent'

    -- Expiration
    expires_at TIMESTAMP,

    -- Metadata
    metadata JSONB,

    -- Timestamps
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for notifications
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_is_read ON notifications(is_read);
CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON notifications(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_notifications_type ON notifications(type);
CREATE INDEX IF NOT EXISTS idx_notifications_booking_id ON notifications(booking_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user_unread ON notifications(user_id, is_read, created_at DESC);

-- Add constraint for notification type
ALTER TABLE notifications DROP CONSTRAINT IF EXISTS notifications_type_check;
ALTER TABLE notifications
ADD CONSTRAINT notifications_type_check
CHECK (type IN ('info', 'success', 'warning', 'error', 'booking', 'payment', 'promotion', 'system'));

-- Add constraint for priority
ALTER TABLE notifications DROP CONSTRAINT IF EXISTS notifications_priority_check;
ALTER TABLE notifications
ADD CONSTRAINT notifications_priority_check
CHECK (priority IN ('low', 'normal', 'high', 'urgent'));

COMMENT ON TABLE notifications IS 'User notification system for app, email, and SMS alerts';

-- =============================================================================
-- Create SERVICE_HISTORY table (if not already exists as vehicle_care_history)
-- =============================================================================

-- The schema already has vehicle_care_history table which serves as service_history
-- Let's add an alias view for easier API access
CREATE OR REPLACE VIEW service_history AS
SELECT
    id,
    vehicle_id,
    booking_id,
    service_type,
    service_date,
    mileage,
    services_performed,
    products_used,
    technician_notes,
    before_photos,
    after_photos,
    cost,
    created_at
FROM vehicle_care_history;

COMMENT ON VIEW service_history IS 'Alias view for vehicle_care_history table for easier API access';

-- Grant permissions
GRANT SELECT ON service_history TO authenticated;

-- =============================================================================
-- Add triggers for new tables
-- =============================================================================

-- Trigger for notifications updated_at
DROP TRIGGER IF EXISTS update_notifications_updated_at ON notifications;
CREATE TRIGGER update_notifications_updated_at
BEFORE UPDATE ON notifications
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =============================================================================
-- Create functions to automatically update counters
-- =============================================================================

-- Function to update user's total_bookings counter
CREATE OR REPLACE FUNCTION update_user_booking_count()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        UPDATE users
        SET total_bookings = total_bookings + 1
        WHERE id = NEW.user_id;
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE users
        SET total_bookings = GREATEST(total_bookings - 1, 0)
        WHERE id = OLD.user_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Function to update service's total_bookings and total_revenue counters
CREATE OR REPLACE FUNCTION update_service_stats()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        -- Increment booking count
        UPDATE services
        SET total_bookings = total_bookings + 1,
            total_revenue = total_revenue + COALESCE(NEW.total_price, 0)
        WHERE id = NEW.service_id;
        RETURN NEW;

    ELSIF (TG_OP = 'UPDATE') THEN
        -- If service completed, update revenue
        IF (OLD.status != 'completed' AND NEW.status = 'completed') THEN
            UPDATE services
            SET total_revenue = total_revenue + COALESCE(NEW.total_price, 0)
            WHERE id = NEW.service_id;
        END IF;
        -- If price changed, adjust revenue
        IF (OLD.total_price != NEW.total_price AND NEW.status = 'completed') THEN
            UPDATE services
            SET total_revenue = total_revenue - COALESCE(OLD.total_price, 0) + COALESCE(NEW.total_price, 0)
            WHERE id = NEW.service_id;
        END IF;
        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
        -- Decrement counters
        UPDATE services
        SET total_bookings = GREATEST(total_bookings - 1, 0),
            total_revenue = GREATEST(total_revenue - COALESCE(OLD.total_price, 0), 0)
        WHERE id = OLD.service_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Create triggers to maintain counters
-- =============================================================================

-- Trigger to update user booking count
DROP TRIGGER IF EXISTS trigger_update_user_booking_count ON bookings;
CREATE TRIGGER trigger_update_user_booking_count
AFTER INSERT OR DELETE ON bookings
FOR EACH ROW EXECUTE FUNCTION update_user_booking_count();

-- Trigger to update service stats
DROP TRIGGER IF EXISTS trigger_update_service_stats ON bookings;
CREATE TRIGGER trigger_update_service_stats
AFTER INSERT OR UPDATE OR DELETE ON bookings
FOR EACH ROW EXECUTE FUNCTION update_service_stats();

-- =============================================================================
-- Backfill existing data (calculate current totals)
-- =============================================================================

-- Update existing users' total_bookings
UPDATE users u
SET total_bookings = (
    SELECT COUNT(*)
    FROM bookings b
    WHERE b.user_id = u.id
)
WHERE total_bookings = 0;

-- Update existing services' total_bookings and total_revenue
UPDATE services s
SET
    total_bookings = (
        SELECT COUNT(*)
        FROM bookings b
        WHERE b.service_id = s.id
    ),
    total_revenue = (
        SELECT COALESCE(SUM(b.total_price), 0)
        FROM bookings b
        WHERE b.service_id = s.id
          AND b.status IN ('completed', 'in_progress')
    )
WHERE total_bookings = 0 OR total_revenue = 0;

-- =============================================================================
-- Create helper functions for notifications
-- =============================================================================

-- Function to create a notification
CREATE OR REPLACE FUNCTION create_notification(
    p_user_id UUID,
    p_title VARCHAR(200),
    p_message TEXT,
    p_type VARCHAR(50) DEFAULT 'info',
    p_booking_id UUID DEFAULT NULL,
    p_action_url TEXT DEFAULT NULL,
    p_priority VARCHAR(20) DEFAULT 'normal'
)
RETURNS UUID AS $$
DECLARE
    v_notification_id UUID;
BEGIN
    INSERT INTO notifications (
        user_id, title, message, type, booking_id, action_url, priority
    ) VALUES (
        p_user_id, p_title, p_message, p_type, p_booking_id, p_action_url, p_priority
    )
    RETURNING id INTO v_notification_id;

    RETURN v_notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to mark notification as read
CREATE OR REPLACE FUNCTION mark_notification_read(p_notification_id UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE notifications
    SET is_read = TRUE,
        read_at = CURRENT_TIMESTAMP
    WHERE id = p_notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to get unread notification count
CREATE OR REPLACE FUNCTION get_unread_count(p_user_id UUID)
RETURNS INTEGER AS $$
DECLARE
    v_count INTEGER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM notifications
    WHERE user_id = p_user_id
      AND is_read = FALSE
      AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP);

    RETURN v_count;
END;
$$ LANGUAGE plpgsql;

-- =============================================================================
-- Create function to auto-notify on booking changes
-- =============================================================================

CREATE OR REPLACE FUNCTION notify_booking_status_change()
RETURNS TRIGGER AS $$
BEGIN
    -- When booking status changes, create notification
    IF (TG_OP = 'UPDATE' AND OLD.status != NEW.status) THEN
        PERFORM create_notification(
            NEW.user_id,
            'Booking Status Updated',
            'Your booking #' || NEW.booking_number || ' status changed to ' || NEW.status,
            'booking',
            NEW.id,
            '/bookings/' || NEW.id,
            'normal'
        );
    END IF;

    -- When booking is created
    IF (TG_OP = 'INSERT') THEN
        PERFORM create_notification(
            NEW.user_id,
            'Booking Confirmed',
            'Your booking #' || NEW.booking_number || ' has been created successfully',
            'booking',
            NEW.id,
            '/bookings/' || NEW.id,
            'normal'
        );
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for automatic booking notifications
DROP TRIGGER IF EXISTS trigger_notify_booking_changes ON bookings;
CREATE TRIGGER trigger_notify_booking_changes
AFTER INSERT OR UPDATE ON bookings
FOR EACH ROW EXECUTE FUNCTION notify_booking_status_change();

-- =============================================================================
-- Add RLS policies for notifications
-- =============================================================================

ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- Users can only see their own notifications
DROP POLICY IF EXISTS "Users can view own notifications" ON notifications;
CREATE POLICY "Users can view own notifications" ON notifications
    FOR SELECT USING (auth.uid() = user_id);

-- Users can mark their own notifications as read
DROP POLICY IF EXISTS "Users can update own notifications" ON notifications;
CREATE POLICY "Users can update own notifications" ON notifications
    FOR UPDATE USING (auth.uid() = user_id);

-- System can create notifications for users
DROP POLICY IF EXISTS "System can create notifications" ON notifications;
CREATE POLICY "System can create notifications" ON notifications
    FOR INSERT WITH CHECK (true);

-- =============================================================================
-- Grant permissions
-- =============================================================================

GRANT SELECT, INSERT, UPDATE ON notifications TO authenticated;
GRANT EXECUTE ON FUNCTION create_notification TO authenticated;
GRANT EXECUTE ON FUNCTION mark_notification_read TO authenticated;
GRANT EXECUTE ON FUNCTION get_unread_count TO authenticated;

-- =============================================================================
-- Create indexes for better performance
-- =============================================================================

-- Additional indexes for common queries
CREATE INDEX IF NOT EXISTS idx_users_total_bookings ON users(total_bookings DESC);
CREATE INDEX IF NOT EXISTS idx_services_total_revenue ON services(total_revenue DESC);
CREATE INDEX IF NOT EXISTS idx_services_total_bookings ON services(total_bookings DESC);
CREATE INDEX IF NOT EXISTS idx_bookings_queue_position ON bookings(queue_position) WHERE queue_position IS NOT NULL;

-- Composite index for active bookings with queue
CREATE INDEX IF NOT EXISTS idx_bookings_status_queue
ON bookings(status, queue_position)
WHERE status IN ('pending', 'confirmed', 'in_progress');

-- =============================================================================
-- Create materialized view for dashboard stats (faster queries)
-- =============================================================================

DROP MATERIALIZED VIEW IF EXISTS dashboard_stats_materialized;
CREATE MATERIALIZED VIEW dashboard_stats_materialized AS
SELECT
    (SELECT COUNT(*) FROM users WHERE is_active = TRUE) as total_active_users,
    (SELECT COUNT(*) FROM users WHERE role = 'customer') as total_customers,
    (SELECT COUNT(*) FROM bookings) as total_bookings,
    (SELECT COUNT(*) FROM bookings WHERE status = 'completed') as completed_bookings,
    (SELECT COUNT(*) FROM bookings WHERE status IN ('pending', 'confirmed')) as pending_bookings,
    (SELECT COUNT(*) FROM bookings WHERE status = 'in_progress') as active_bookings,
    (SELECT COALESCE(SUM(total_price), 0) FROM bookings WHERE status = 'completed') as total_revenue,
    (SELECT COALESCE(AVG(total_price), 0) FROM bookings WHERE status = 'completed') as avg_booking_value,
    (SELECT COUNT(*) FROM users WHERE DATE(created_at) >= CURRENT_DATE - INTERVAL '30 days') as new_users_30d,
    (SELECT COUNT(*) FROM bookings WHERE DATE(created_at) = CURRENT_DATE) as bookings_today,
    (SELECT COALESCE(SUM(total_price), 0) FROM bookings WHERE DATE(created_at) = CURRENT_DATE AND status = 'completed') as revenue_today,
    CURRENT_TIMESTAMP as last_updated;

-- Create index on materialized view
CREATE UNIQUE INDEX idx_dashboard_stats_mat ON dashboard_stats_materialized (last_updated);

COMMENT ON MATERIALIZED VIEW dashboard_stats_materialized IS 'Cached dashboard statistics for ultra-fast loading';

-- Grant access
GRANT SELECT ON dashboard_stats_materialized TO authenticated;

-- Function to refresh dashboard stats (call this periodically via cron)
CREATE OR REPLACE FUNCTION refresh_dashboard_stats()
RETURNS VOID AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY dashboard_stats_materialized;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION refresh_dashboard_stats TO authenticated;

-- =============================================================================
-- Update schema version
-- =============================================================================

INSERT INTO schema_version (version, description)
VALUES ('2.2.0', 'Database schema completion: Added counters, notifications table, service_history view, triggers, and materialized views')
ON CONFLICT (version) DO NOTHING;

-- =============================================================================
-- Verification queries
-- =============================================================================

DO $$
DECLARE
    v_users_total_bookings BOOLEAN;
    v_services_total_bookings BOOLEAN;
    v_services_total_revenue BOOLEAN;
    v_bookings_queue_position BOOLEAN;
    v_notifications_exists BOOLEAN;
BEGIN
    -- Check if all new columns exist
    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'users' AND column_name = 'total_bookings'
    ) INTO v_users_total_bookings;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'services' AND column_name = 'total_bookings'
    ) INTO v_services_total_bookings;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'services' AND column_name = 'total_revenue'
    ) INTO v_services_total_revenue;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.columns
        WHERE table_name = 'bookings' AND column_name = 'queue_position'
    ) INTO v_bookings_queue_position;

    SELECT EXISTS (
        SELECT 1 FROM information_schema.tables
        WHERE table_name = 'notifications'
    ) INTO v_notifications_exists;

    -- Output results
    RAISE NOTICE '=============================================================================';
    RAISE NOTICE 'Migration 006 - Database Schema Completion - VERIFICATION';
    RAISE NOTICE '=============================================================================';
    RAISE NOTICE 'Users.total_bookings added: %', v_users_total_bookings;
    RAISE NOTICE 'Services.total_bookings added: %', v_services_total_bookings;
    RAISE NOTICE 'Services.total_revenue added: %', v_services_total_revenue;
    RAISE NOTICE 'Bookings.queue_position added: %', v_bookings_queue_position;
    RAISE NOTICE 'Notifications table created: %', v_notifications_exists;
    RAISE NOTICE 'Service_history view created: TRUE';
    RAISE NOTICE 'Dashboard materialized view created: TRUE';
    RAISE NOTICE 'Auto-update triggers created: TRUE';
    RAISE NOTICE 'Notification functions created: TRUE';
    RAISE NOTICE '=============================================================================';
    RAISE NOTICE 'Schema version updated to 2.2.0';
    RAISE NOTICE 'Migration completed successfully!';
    RAISE NOTICE '=============================================================================';
END $$;
