rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // HELPER FUNCTIONS
    // ============================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Role-based access via Firebase Custom Claims
    function isManager() {
      return isAuthenticated() && request.auth.token.role == 'manager';
    }

    function isStaff() {
      return isAuthenticated() && request.auth.token.role == 'staff';
    }

    function isManagerOrStaff() {
      return isManager() || isStaff();
    }

    function isValidPhoneNumber(phone) {
      return phone is string && phone.matches('^\\+?[0-9]{9,15}$');
    }

    function isValidEmail(email) {
      return email is string && email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    function isValidBookingStatus(status) {
      return status in ['pending', 'confirmed', 'on_the_way', 'in_progress', 'completed', 'cancelled'];
    }

    function isValidVehicleType(type) {
      return type in ['sedan', 'suv', 'truck', 'van', 'motorcycle', 'caravan', 'boat'];
    }

    function isValidPackage(pkg) {
      return pkg in ['platinum', 'titanium', 'diamond', 'Platinum', 'Titanium', 'Diamond'];
    }

    function isRecentTimestamp(ts) {
      return ts is timestamp
        && ts >= request.time - duration.value(5, 'm')
        && ts <= request.time + duration.value(1, 'm');
    }

    function isValidStringLength(str, minLen, maxLen) {
      return str is string && str.size() >= minLen && str.size() <= maxLen;
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Owner can read their own doc; managers can read any user
      allow read: if isOwner(userId) || isManager();

      // Allow create only if authenticated and creating own document
      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['phone', 'createdAt'])
        && isValidStringLength(request.resource.data.phone, 9, 15)
        && request.resource.data.createdAt is timestamp
        && (!('email' in request.resource.data) || request.resource.data.email == '' || isValidEmail(request.resource.data.email))
        && (!('name' in request.resource.data) || isValidStringLength(request.resource.data.name, 0, 100))
        && (!('language' in request.resource.data) || request.resource.data.language in ['en', 'ar'])
        && (!('theme' in request.resource.data) || request.resource.data.theme in ['light', 'dark'])
        && !('loyaltyPoints' in request.resource.data)
        && !('totalBookings' in request.resource.data)
        && request.resource.data.keys().size() <= 15;

      // Owner can update their own doc; manager can update any user
      allow update: if (isOwner(userId) || isManager())
        && request.resource.data.phone == resource.data.phone
        && request.resource.data.createdAt == resource.data.createdAt
        && (!('email' in request.resource.data) || request.resource.data.email == '' || isValidEmail(request.resource.data.email))
        && (!('name' in request.resource.data) || isValidStringLength(request.resource.data.name, 0, 100))
        && (!('language' in request.resource.data) || request.resource.data.language in ['en', 'ar'])
        && (!('theme' in request.resource.data) || request.resource.data.theme in ['light', 'dark'])
        && (!('loyaltyPoints' in request.resource.data) || request.resource.data.loyaltyPoints == resource.data.loyaltyPoints || isManager())
        && request.resource.data.keys().size() <= 15;

      allow delete: if false;

      // VEHICLES SUB-COLLECTION
      match /vehicles/{vehicleId} {
        allow read: if isOwner(userId);

        allow create: if isOwner(userId)
          && request.resource.data.keys().hasAll(['type', 'createdAt'])
          && isValidVehicleType(request.resource.data.type)
          && request.resource.data.createdAt is timestamp
          && (!('make' in request.resource.data) || isValidStringLength(request.resource.data.make, 0, 50))
          && (!('model' in request.resource.data) || isValidStringLength(request.resource.data.model, 0, 50))
          && (!('color' in request.resource.data) || isValidStringLength(request.resource.data.color, 0, 30))
          && (!('nickname' in request.resource.data) || isValidStringLength(request.resource.data.nickname, 0, 50))
          && request.resource.data.keys().size() <= 10;

        allow update: if isOwner(userId)
          && request.resource.data.createdAt == resource.data.createdAt
          && isValidVehicleType(request.resource.data.type)
          && (!('make' in request.resource.data) || isValidStringLength(request.resource.data.make, 0, 50))
          && (!('model' in request.resource.data) || isValidStringLength(request.resource.data.model, 0, 50))
          && (!('color' in request.resource.data) || isValidStringLength(request.resource.data.color, 0, 30))
          && (!('nickname' in request.resource.data) || isValidStringLength(request.resource.data.nickname, 0, 50));

        allow delete: if isOwner(userId);
      }

      // LOCATIONS SUB-COLLECTION
      match /locations/{locationId} {
        allow read: if isOwner(userId);

        allow create: if isOwner(userId)
          && request.resource.data.keys().hasAll(['area', 'villa', 'createdAt'])
          && isValidStringLength(request.resource.data.area, 1, 100)
          && isValidStringLength(request.resource.data.villa, 1, 100)
          && request.resource.data.createdAt is timestamp
          && (!('street' in request.resource.data) || isValidStringLength(request.resource.data.street, 0, 200))
          && (!('nickname' in request.resource.data) || isValidStringLength(request.resource.data.nickname, 0, 50))
          && request.resource.data.keys().size() <= 10;

        allow update: if isOwner(userId)
          && request.resource.data.createdAt == resource.data.createdAt
          && isValidStringLength(request.resource.data.area, 1, 100)
          && isValidStringLength(request.resource.data.villa, 1, 100);

        allow delete: if isOwner(userId);
      }
    }

    // ============================================
    // BOOKINGS COLLECTION
    // Bookings are created server-side via createBooking Cloud Function.
    // Clients can only read their own bookings and cancel pending ones.
    // Managers/staff can read all and update status.
    // ============================================
    match /bookings/{bookingId} {
      // Customer can read own bookings; manager/staff can read all
      allow read: if isManagerOrStaff()
        || (isAuthenticated() && resource.data.userId == request.auth.uid);

      // No client-side create — bookings are created via Cloud Function (Admin SDK)
      allow create: if false;

      // Customer can only cancel their own pending bookings
      // Manager/staff can update status and other fields
      allow update: if
        // Manager/staff: can update any booking
        isManagerOrStaff()
        ||
        // Customer: can only cancel own pending booking
        (
          isAuthenticated()
          && resource.data.userId == request.auth.uid
          && request.resource.data.userId == resource.data.userId
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.price == resource.data.price
          && (
            request.resource.data.status == resource.data.status ||
            (resource.data.status == 'pending' && request.resource.data.status == 'cancelled')
          )
        );

      // Customer can delete own pending/cancelled bookings
      allow delete: if isAuthenticated()
        && resource.data.userId == request.auth.uid
        && resource.data.status in ['pending', 'cancelled'];
    }

    // ============================================
    // CONFIG COLLECTION
    // App configuration (add-ons, business hours, etc.)
    // ============================================
    match /config/{docId} {
      // Any authenticated user can read config
      allow read: if isAuthenticated();

      // Only managers can write config
      allow write: if isManager();
    }

    // ============================================
    // AUDIT LOG COLLECTION
    // Written only by Cloud Functions via Admin SDK
    // ============================================
    match /auditLog/{entryId} {
      // Only managers can read audit logs
      allow read: if isManager();

      // No client writes — only Admin SDK
      allow write: if false;
    }

    // ============================================
    // LOYALTY COLLECTION
    // ============================================
    match /loyalty/{userId} {
      allow read: if isOwner(userId) || isManager();

      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['washCount', 'freeWashAvailable', 'lastUpdated'])
        && request.resource.data.washCount is int
        && request.resource.data.washCount == 0
        && request.resource.data.freeWashAvailable == false
        && request.resource.data.lastUpdated is timestamp;

      allow update: if isOwner(userId)
        && request.resource.data.washCount is int
        && request.resource.data.washCount >= 0
        && request.resource.data.washCount <= 1000
        && request.resource.data.freeWashAvailable is bool
        && request.resource.data.lastUpdated is timestamp
        && (
          (request.resource.data.washCount == resource.data.washCount + 1) ||
          (resource.data.freeWashAvailable == true &&
           request.resource.data.washCount == 0 &&
           request.resource.data.freeWashAvailable == false) ||
          (request.resource.data.washCount == resource.data.washCount &&
           resource.data.washCount >= 6 &&
           request.resource.data.freeWashAvailable == true)
        );

      allow delete: if false;
    }

    // Legacy loyalty sub-collection
    match /users/{userId}/loyalty/{loyaltyId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['count', 'lastUpdated'])
        && request.resource.data.count is int
        && request.resource.data.count >= 0
        && request.resource.data.lastUpdated is timestamp;
      allow update: if isOwner(userId)
        && request.resource.data.count is int
        && request.resource.data.count >= 0
        && request.resource.data.lastUpdated is timestamp
        && (request.resource.data.count <= resource.data.count + 1);
      allow delete: if false;
    }

    // ============================================
    // GUEST BOOKINGS COLLECTION
    // Guest bookings now also go through createBooking Cloud Function.
    // This collection kept for legacy reads only.
    // ============================================
    match /guestBookings/{bookingId} {
      allow read: if request.auth == null
                  && resource.data.guestSessionId is string
                  && resource.data.guestSessionId.size() >= 32;

      // No client creates — handled by Cloud Function
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // ============================================
    // DENY ALL OTHER ACCESS
    // ============================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
